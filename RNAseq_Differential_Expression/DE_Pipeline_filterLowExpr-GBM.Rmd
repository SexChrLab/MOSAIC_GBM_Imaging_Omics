---
title: "Differential Gene Expression Pipeline"
author: "Seema Plaisier"
date: "`r format(Sys.time(), '%m/%d/%y')`"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

# Applying the DE Pipeline 

This pipeline is adapted from the limma workflow vignette on Bioconductor:
https://bioconductor.org/packages/release/workflows/vignettes/RNAseq123/inst/doc/limmaWorkflow.html

```{r ReportingOptions, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60),tidy=TRUE)
```

# Load packages

Install the necessary packages for our analysis.  The function 'require' returns a true value if it is already installed, so if it is not, we need to install before loading

```{r Packages, warning=FALSE}

if(!require(gplots)){
    install.packages("gplots")
}
if(!require(ggplot2)){
    install.packages("ggplot2")
}
if(!require(Polychrome)){
    install.packages("Polychrome")
}
if(!require(RColorBrewer)){
    install.packages("RColorBrewer")
}
if(!require(ggpubr)){
    install.packages("ggpubr")
}
if (!require("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
}
if(!require(EnhancedVolcano)){
  BiocManager::install("EnhancedVolcano")
}
if(!require(limma)){
  BiocManager::install("limma")
}
if(!require(edgeR)){
  BiocManager::install("edgeR")
}
if(!require(biomaRt)){
  BiocManager::install("biomaRt")
}

library(gplots)
library(ggplot2)
library(limma)
library(ggpubr)
library(edgeR)
library(Polychrome)
library(RColorBrewer)
library(EnhancedVolcano)
library(biomaRt)
library(matrixStats)
library(pheatmap)
library(readxl)
library(readr)
library(reshape2)

library(tidyverse)
library(GSVA)
library(GSEABase)
library(pheatmap)
library(variancePartition)
library(dplyr)

library(rgl)
```

# Set working directory

Your working directory is where all your output files are going to be saved.

``` {r WorkingDirectory, tidy=TRUE, tidy.opts=list(width.cutoff=60)}

input_directory = "C:/Users/splaisie/Dropbox (ASU)/RNA_Metadata_Wilson_Swanson/RNA_Analysis/"

```

# Read in data

Read in datasets containing genesID, phenotypes, and genecounts. We will be using DGElists for organizing information.  Also checks if the counts and pheno data are in the same order-- if not, halts processing since that is assumed going forward.

```{r DataSetup, tidy=TRUE, tidy.opts=list(width.cutoff=60)}
# Save imported data as variables
pheno <- read.delim(paste0(input_directory,"pheno.csv"), header=TRUE, sep=",", check.names = FALSE)
expr_data <- read.delim(paste0(input_directory,"geneCounts_all.csv"), header=TRUE, sep=",", check.names = FALSE)

check_counts = colnames(expr_data)[2:length(expr_data)]
check_pheno = pheno$RNA_ID_SCC
check_counts == check_pheno
if (! all (check_counts == check_pheno)) {
  stop("pheno file has to have the same sample order as counts")
}

# set row names with a unique version of those gene names
counts = expr_data[2:length(expr_data)]
row.names(counts)=make.unique(expr_data$Geneid) 
dim(counts) # check out how much you have in your counts file

#filter out G6_F_XX since it had unusual low expression in normalization boxplot
counts = counts[, -which(names(counts) %in% c("G6_F_XX"))]
pheno = pheno[pheno$RNA_ID_SCC != "G6_F_XX" , ]

#filter out G40_NE_I_XX, G40_CE_D_XX, G23_CE_B_XY,M20_CE_D_XY, M20_CE_B_XY, M24_NE_C_XY, since it had unusual low expression in normalization boxplot after removing G6_F_XX
rem_list = c("G40_NE_I_XX", "G40_CE_D_XX", "G23_CE_B_XY", "M20_CE_D_XY", "M20_CE_B_XY", "M24_NE_C_XY")
counts = counts[, -which(names(counts) %in% rem_list)]
pheno = pheno[!pheno$RNA_ID_SCC %in% rem_list, ]

# Create a new DGElist object
x <- DGEList(counts = counts, lib.size = colSums(counts), norm.factors = rep(1,ncol(counts)), samples = colnames(counts), group = pheno$Sex, genes = row.names(counts), remove.zeros = TRUE)
dim(x) # show how much is left after removing all-zero rows

samplenames = colnames(x) #save sample names for plotting below

# store sample phenotypes that we are grouping samples by
group = as.factor(pheno$Subject.ID)
x$samples$group <- group
head(x$samples)

```

# Data Preprocessing
For differential expression and related analyses, gene expression is rarely considered at the level of raw counts since libraries sequenced at a greater depth will result in higher counts. Rather, it is common practice to transform raw counts onto a scale that accounts for such library size differences. Popular transformations include counts per million (CPM), log2-counts per million (log-CPM), reads per kilobase of transcript per million (RPKM), and fragments per kilobase of transcript per million (FPKM).

Here raw counts are converted to CPM and log-CPM values using the cpm function in edgeR. 

CPM values adjust for the fact that some genes were sequenced more than others. A CPM value of 1 for a gene equates to having 20 counts in the sample with the lowest sequencing depth or 76 counts in the sample with the greatest sequencing depth 

When the parameter 'log' is set to 'TRUE', the cpm function adds an offset to the CPM values before converting to the log2-scale. By default, the offset is 2/L where 2 is the “prior count” and L is the average library size in millions, so the log-CPM values are related to the CPM values by log2(CPM + 2/L). This calculation ensures that any two read counts with identical CPM values will also have identical log-CPM values. 

```{r Preprocessing, tidy=TRUE, tidy.opts=list(width.cutoff=60)}

# convert raw counts to CPM and log-CPM values using cpm function in edgeR
cpm <- cpm(x)
lcpm <- cpm(x, log=TRUE) 

write.csv(lcpm, file = "lcpm.csv",row.names = TRUE)

# calculate the mean and median of the counts
#  (we multiply by 1e-6 to represent the mean and median in millions)
L <- mean(x$samples$lib.size) * 1e-6
M <- median(x$samples$lib.size) * 1e-6
c(L, M)  # see what the mean and median are

```

# Removing genes that are lowly expressed 
All datasets will include a mix of genes that are expressed and those that are not expressed. Whilst it is of interest to examine genes that are expressed in one condition but not in another, some genes are unexpressed throughout all samples.

Genes that do not have a worthwhile number of reads in any sample should be filtered out of the downstream analyses. There are several reasons for this. From a biological point of view, genes that not expressed at a biologically meaningful level in any condition are not of interest and are therefore best ignored. From a statistical point of view, removing low count genes allows the mean-variance relationship in the data to be estimated with greater reliability and also reduces the number of statistical tests that need to be carried out in downstream analyses looking at differential expression.


```{r FilterLowExpression, tidy=TRUE, tidy.opts=list(width.cutoff=60)}

# filter genes using the filterByExpr function in edgeR
keep.exprs <- filterByExpr(x, group=group)
x <- x[keep.exprs,, keep.lib.sizes=FALSE]
dim(x) # see how much remains after filtering out low expression genes

```

# Normalising gene expression distributions
During the sample preparation or sequencing process, external factors that are not of biological interest can affect the expression of individual samples. For example, samples processed in the first batch of an experiment can have higher expression overall when compared to samples processed in a second batch. It is assumed that all samples should have a similar range and distribution of expression values. Any plot showing the per sample expression distributions, such as a density or boxplot, is useful in determining whether any samples are dissimilar to others. 

Normalisation is required to ensure that the expression distributions of each sample are similar across the entire experiment. Normalisation by the method of trimmed mean of M-values (TMM) (Robinson and Oshlack 2010) is performed using the calcNormFactors function in edgeR. The normalisation factors calculated here are used as a scaling factor for the library sizes. When working with DGEList-objects, these normalisation factors are automatically stored in x$samples$norm.factors. For this dataset the effect of TMM-normalisation is mild, as evident in the magnitude of the scaling factors, which are all relatively close to 1.

```{r Normalization, tidy=TRUE, tidy.opts=list(width.cutoff=60), fig.height=8}

#pdf("Normalization_rem_G6_F_XX_list.pdf", width = 12, height = 8)
pdf("Normalization_rem_G6_F_XX_list_wide.pdf", width = 40, height = 8)

# use calcNormFactors function to calculate how much you want to multiply by to make sure the data are in comparable range to one another
x_norm <- calcNormFactors(x, method = "TMM")
x_norm$samples$norm.factors

#Show the expression distribution of samples unnormalized vs normalized using box plots
 
# Custom color palette
palette = createPalette(39,  c("#ff0000", "#00ff00", "#0000ff"))  

# convert raw data applied to CPM
lcpm <- cpm(x, log=TRUE)

# plot raw data CPM (gene quantification)
# ** run these next two lines together (highlight both lines, Run, Run selected lines)**
par(mfrow=c(2,1))
boxplot(lcpm, las=2, cex.axis=0.5, col=as.vector(palette), main="")
title(main="A. Unnormalized data",ylab="Log-cpm")

# convert data with normalization factors applied to CPM
lcpm_norm <- cpm(x_norm, log=TRUE)

write.csv(lcpm_norm,file = "lcpm_norm.csv",row.names = TRUE)

# plot normalized CPM (gene quantification)
# ** run these next two lines together (highlight both lines, Run, Run selected lines)**
boxplot(lcpm_norm, las=2, cex.axis=0.5, col=as.vector(palette), main="")
title(main="B. Normalized data",ylab="Log-cpm")
dev.off()
```

# Separation of samples

One of the most important exploratory plots to examine for gene expression analyses is the multi-dimensional scaling (MDS) plot, or similar. The plot shows similarities and dissimilarities between samples in an unsupervised manner so that one can have an idea of the extent to which differential expression can be detected before carrying out formal tests. Ideally, samples would cluster well within the primary condition of interest, and any sample straying far from its group could be identified and followed up for sources of error or extra variation. If present, technical replicates should lie very close to one another.


```{r MDSPlot, tidy=TRUE, tidy.opts=list(width.cutoff=60)}

# label and color sex --> MDS plot
col.sex <- as.factor(pheno$Sex) # set to sex
levels(col.sex) # F and M
levels(col.sex) = c("orange","blue") # map colors to sex
plotMDS(lcpm_norm, labels=pheno$RNA_ID, col=as.character(col.sex), cex=0.5, top = 25)
title(main="Sex (top 25 genes)")
legend("bottomleft",legend = c("F","M"), title = "Sex", fill = c("orange", "blue"), cex = 0.75, horiz = TRUE)

# label and color cohort --> MDS plot
col.cohort <- as.factor(pheno$Cohort) # set to cohort
levels(col.cohort) # D3,D4,D5,D6
levels(col.cohort) = c("red", "blue", "green", "grey") # map colors to cohort
plotMDS(lcpm_norm, labels=pheno$RNA_ID, col=as.character(col.cohort), cex=0.5, top = 25)
title(main="Cohort (top 25 genes)")
legend("bottomleft",legend = c("D3","D4","D5","D6"), title = "Cohort", fill = c("red", "blue", "green", "grey"), cex = 0.75, horiz = TRUE)

col.seqbatch <- as.factor(pheno$Sequencing_Batch) # set to sequencing batch
levels(col.seqbatch) # D3,D4,D5,D6, D6_lowinput
levels(col.seqbatch) = c("red", "blue", "green", "grey", "black") # map colors to seqbatch
plotMDS(lcpm_norm, labels=pheno$RNA_ID, col=as.character(col.seqbatch), cex=0.5, top = 25)
title(main="Sequencing Batch (top 25 genes)")
legend("bottomleft",legend = c("D3","D4","D5","D6","D6_lowinput"), title = "seqbatch", fill = c("red", "blue", "green", "grey","black"), cex = 0.75, horiz = TRUE, x.intersp = 0.25, text.width = 0.5)

# label and color grade --> MDS plot
col.grade <- as.factor(pheno$Grade) # set to grade
levels(col.grade) # 2 , 3, 4, Unk
levels(col.grade) = c("darkgoldenrod2", "red", "darkred", "grey") # map colors to grade
plotMDS(lcpm_norm, labels=pheno$RNA_ID, col=as.character(col.grade), cex=0.5, top = 25)
title(main="Grade (top 25 genes)")
legend("bottomleft",legend = c("2","3","4","Unk"), title = "Grade", fill = c("darkgoldenrod2", "red", "darkred", "grey"), cex = 0.75, horiz = TRUE)

# label and color recurrance --> MDS plot
col.recurrance <- as.factor(pheno$Primary.Recurrent) # set to recurrance
levels(col.recurrance) # Primary, Recurrent
levels(col.recurrance) = c("green4","purple") # map colors to recurrance
plotMDS(lcpm_norm, labels=pheno$RNA_ID, col=as.character(col.recurrance), cex=0.5, top = 25)
title(main="Recurrance (top 25 genes)")
legend("bottomleft",legend = c("Primary","Recurrent"), title = "Recurrance", fill = c("green4", "purple"), cex = 0.75, horiz = TRUE)

# label and color patient --> MDS plot
col.patient <- as.factor(pheno$Subject.ID) # set to patient
levels(col.patient) # 60 patients

# get a list of distinct colors
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
patient_colors = sample(col_vector, length(levels(col.patient))) # select distinct colors for each patient
levels(col.patient) = patient_colors

par(mar=c(5, 4, 4, 8), xpd=TRUE)
plotMDS(lcpm_norm, labels=pheno$RNA_ID, col=as.character(col.patient), cex=0.5, top = 25)
title(main="patient (top 25 genes)")
legend("topright",inset = c(-0.3,0.02), legend = levels(as.factor(pheno$Subject.ID)), title = "Subject", fill = patient_colors, cex = 0.4,ncol = 2)


```

# Batch correction

Having seen that batch is a major source of variation that we are not interested in, we use the removeBatchEffect function to adjust the data to remove variation that is due to differences in sequencing batch.

```{r batchcorrect, eval=FALSE, include=FALSE}

lcpm_norm_batchcorrect = removeBatchEffect(lcpm_norm, batch=pheno$Cohort)

# label and color cohort --> MDS plot
plotMDS(lcpm_norm_batchcorrect, labels=pheno$RNA_ID, col=as.character(col.cohort), cex=0.5, top = 25)
title(main="Cohort (top 25 genes), batch corrected")
legend("topright",legend = c("D3","D4","D5","D6"), title = "Cohort", fill = c("red", "blue", "green", "grey"), cex = 0.75, horiz = TRUE)

# label and color sex --> MDS plot
plotMDS(lcpm_norm_batchcorrect, labels=pheno$RNA_ID, col=as.character(col.sex), cex=0.5, top = 25)
title(main="Sex (top 25 genes), batch corrected")
legend("topright",legend = c("F","M"), title = "Sex", fill = c("orange", "blue"), cex = 0.75, horiz = TRUE)

plotMDS(lcpm_norm_batchcorrect, labels=pheno$RNA_ID, col=as.character(col.sex), cex=0.5, top = 25, dim.plot = c(2,3))
title(main="Sex (top 25 genes), batch corrected")
legend("topright",legend = c("F","M"), title = "Sex", fill = c("orange", "blue"), cex = 0.75, horiz = TRUE)

# label and color grade --> MDS plot
plotMDS(lcpm_norm_batchcorrect, labels=pheno$RNA_ID, col=as.character(col.grade), cex=0.5, top = 25)
title(main="Grade (top 25 genes), batch corrected")
legend("topright",legend = c("2","3","4","Unk"), title = "Grade", fill = c("darkgoldenrod2", "red", "darkred", "grey"), cex = 0.75, horiz = TRUE)

# label and color recurrance --> MDS plot
plotMDS(lcpm_norm_batchcorrect, labels=pheno$RNA_ID, col=as.character(col.recurrance), cex=0.5, top = 25)
title(main="Recurrance (top 25 genes), batch corrected")
legend("topright",legend = c("Primary","Recurrent"), title = "Recurrance", fill = c("green4", "purple"), cex = 0.75, horiz = TRUE)

# label and color patient --> MDS plot
par(mar=c(5, 4, 4, 8), xpd=TRUE)
plotMDS(lcpm_norm_batchcorrect, labels=pheno$RNA_ID, col=as.character(col.patient), cex=0.5, top = 25)
title(main="Patient (top 25 genes), batch corrected")
legend("topright",inset = c(-0.3,0.02), legend = levels(as.factor(pheno$Subject.ID)), title = "Subject", fill = patient_colors, cex = 0.4,ncol = 2)


```

There are two annotations for batch-- "Cohort" and "Sequencing_Batch".  At first, I was using cohort but then I saw Sequencing_Batch and realized that that would be more close to what we are interested in capturing.

```{r seqseqbatchcorrect}

lcpm_norm_seqbatchcorrect = removeBatchEffect(lcpm_norm, batch=pheno$Sequencing_Batch)
write.csv(lcpm_norm_seqbatchcorrect, file = paste0(input_directory,"lcpm_norm_seqbatchcorrect.csv"),row.names = TRUE)

# label and color cohort --> MDS plot
plotMDS(lcpm_norm_seqbatchcorrect, labels=pheno$RNA_ID, col=as.character(col.seqbatch), cex=0.5, top = 25)
title(main="Cohort (top = 25 genes), sequencing batch corrected")
legend("topright",legend = c("D3","D4","D5","D6","D6_lowinput"), title = "Cohort", fill = c("red", "blue", "green", "grey", "black"), cex = 0.75)

# label and color sex --> MDS plot
plotMDS(lcpm_norm_seqbatchcorrect, labels=pheno$RNA_ID, col=as.character(col.sex), cex=0.5, top = 25)
title(main="Sex (top = 25 genes), sequencing batch corrected")
legend("bottomleft",legend = c("F","M"), title = "Sex", fill = c("orange", "blue"), cex = 0.75)

plotMDS(lcpm_norm_seqbatchcorrect, labels=pheno$RNA_ID, col=as.character(col.sex), cex=0.5, top = 25, dim.plot = c(2,3))
title(main="Sex (top = 25 genes), sequencing batch corrected")
legend("topright",legend = c("F","M"), title = "Sex", fill = c("orange", "blue"), cex = 0.75)

# label and color grade --> MDS plot
plotMDS(lcpm_norm_seqbatchcorrect, labels=pheno$RNA_ID, col=as.character(col.grade), cex=0.5, top = 25)
title(main="Grade (top = 25 genes), sequencing batch corrected")
legend("bottomleft",legend = c("2","3","4","Unk"), title = "Grade", fill = c("darkgoldenrod2", "red", "darkred", "grey"), cex = 0.75)

# label and color recurrance --> MDS plot
plotMDS(lcpm_norm_seqbatchcorrect, labels=pheno$RNA_ID, col=as.character(col.recurrance), cex=0.5, top = 25)
title(main="Recurrance (top = 25 genes), sequencing batch corrected")
legend("bottomleft",legend = c("Primary","Recurrent"), title = "Recurrance", fill = c("green4", "purple"), cex = 0.75)

# label and color patient --> MDS plot
par(mar=c(5, 4, 4, 8), xpd=TRUE)
plotMDS(lcpm_norm_seqbatchcorrect, labels=pheno$RNA_ID, col=as.character(col.patient), cex=0.5, top = 25)
title(main="Patient (top = 25 genes), sequencing batch corrected")
legend("topright",inset = c(-0.3,0.02), legend = levels(as.factor(pheno$Subject.ID)), title = "Subject", fill = patient_colors, cex = 0.4,ncol = 2)

# label and color imaging --> MDS plot
imaging_phenotypes = pheno$Annotation
imaging_phenotypes[grep("BAT",imaging_phenotypes)] = "NonENH"
imaging_phenotypes[grep("NE",imaging_phenotypes)] = "NonENH"
imaging_phenotypes[grep("CE",imaging_phenotypes)] = "ENH"
imaging_phenotypes[grep("Central Cyst/Cavity",imaging_phenotypes)] = "Cyst_Cavity"
imaging_phenotypes[grep("Necrosis",imaging_phenotypes)] = "NEC"
col.imaging <- as.factor(imaging_phenotypes) # set to imaging
levels(col.imaging) #"Cyst_Cavity" "ENH"         "NEC"         "NonENH"
levels(col.imaging) = c("green","red", "grey","blue") # map colors to imaging types
plotMDS(lcpm_norm_seqbatchcorrect, labels=imaging_phenotypes, col=as.character(col.imaging), cex=0.5, top = 25, dim.plot = c(1,2))
title(main="Imaging (top = 25 genes), sequencing batch corrected")
legend("bottomleft",legend = c("Cyst_Cavity", "ENH","NEC","NonENH"), title = "Imaging", fill = c("green","red", "grey","blue"), cex = 0.5)

plotMDS(lcpm_norm_seqbatchcorrect, labels=pheno$Annotation, col=as.character(col.imaging), cex=0.5, top = 25, dim.plot = c(2,3))
title(main="Imaging (top = 25 genes), sequencing batch corrected")
legend("topleft",legend = c("BAT", "CE", "Central Cyst/Cavity", "ENH", "NE", "NEC", "Necrosis"), title = "Imaging", fill = c("red","orange", "green", "blue","purple","grey", "darkblue"), cex = 0.5)

# label and color age --> MDS plot
col.age = as.factor(pheno$Age.at.U01.Diagnosis)
levels(col.age)
levels(col.age) = c(rep("#FFDB58",6), rep("#d9f0a3",2), rep("#addd8e",5),rep("#78c679",5), rep("#41ab5d",8),rep("#238443",6),rep("#005a32",2)) # map colors to age in decades
plotMDS(lcpm_norm_seqbatchcorrect, labels=pheno$Age.at.U01.Diagnosis, cex=0.5, col=as.character(col.age), top = 25, dim.plot = c(1,2))
title(main="Age at Diagnosis (top = 25 genes), sequencing batch corrected")
legend("bottomleft",legend = c("20s","30s","40s","50s","60s","70s","80s"), title = "Age", fill = c("#FFDB58","#d9f0a3", "#addd8e", "#78c679","#41ab5d","#238443", "#005a32"), cex = 0.75)


```
# Samples Per Patient

In this chunk, we are pulling out the number and distribution of samples per patient and displaying them in violin plots and histograms.  In some cases, there are not enough samples per patient to create the visualization, so what we are left with is the patients for which there are multiple samples to look across. 

```{r SamplesPerPatient}

patient_list = as.factor(pheno$Subject.ID)
sample_number = data.frame(table(patient_list))

female_patients = levels(as.factor(pheno$Subject.ID[pheno$Sex == "F"]))
male_patients = levels(as.factor(pheno$Subject.ID[pheno$Sex == "M"]))

sample_number_females = sample_number %>% filter(patient_list %in% female_patients)
sample_number_males = sample_number %>% filter(patient_list %in% male_patients)

# function from the internet to get the floor so you can have integer axes
integer_breaks <- function(n = 5, ...) {
  fxn <- function(x) {
    breaks <- floor(pretty(x, n, ...))
    names(breaks) <- attr(breaks, "labels")
    breaks
  }
  return(fxn)
}

ggplot(sample_number, aes(x=reorder(patient_list,+Freq),y=as.numeric(Freq))) + geom_bar(stat="identity",fill="steelblue") + theme_minimal() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + scale_y_continuous(breaks = integer_breaks()) + ylab("Count") + xlab("Subject.ID (Surgery)") + ggtitle("Sample number for all Patients (Surgeries)")

ggplot(sample_number_females, aes(x=reorder(patient_list,+Freq),y=as.numeric(Freq))) + geom_bar(stat="identity",fill="orange") + theme_minimal() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + scale_y_continuous(breaks = integer_breaks()) + ylab("Count") + xlab("Subject.ID (Surgery)") + ggtitle("Sample number for Female Patients (Surgeries)")

hist(sample_number_females$Freq, main = "Histogram of Number of samples per Female Patient (surgery)", xlab = "Number of Samples", ylab = "Number patients/surgeries (Subject.ID), out of 22 total", col = "orange", xlim = c(0,10))

ggplot(sample_number_males, aes(x=reorder(patient_list,+Freq),y=as.numeric(Freq), fill = "blue")) + geom_bar(stat="identity",fill="steelblue") + theme_minimal() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + scale_y_continuous(breaks = integer_breaks()) + ylab("Count") + xlab("Subject.ID (Surgery)") + ggtitle("Sample number for Male Patients (Surgeries)")

hist(sample_number_males$Freq, main = "Histogram of Number of samples per Male Patient (surgery)", xlab = "Number of Samples", ylab = "Number patients/surgeries (Subject.ID), out of 38 total", col = "steelblue", xlim = c(0,10))


```

# Primary vs Recurrant

Just looking to see how many patients had primary tumor samples and tumors that showed up when the patient relapsed.  If we use Subject.ID as the patient identifier, there are none.  If we use PV.ID as the patient identifier, there is one.  So all in all, not a lot of patients to look at in this category. 

```{r PrimRec}

prim_list_patients = pheno$Subject.ID[pheno$Primary.Recurrent == "Primary"]
recur_list_patients = pheno$Subject.ID[pheno$Primary.Recurrent == "Recurrent"]

both_prim_rec_patients = intersect(prim_list_patients, recur_list_patients)
#empty!  No patients that have surgeries of both primary and recurrant tumors

prim_list_patients = pheno$PV.ID[pheno$Primary.Recurrent == "Primary"]
recur_list_patients = pheno$PV.ID[pheno$Primary.Recurrent == "Recurrent"]

both_prim_rec_patients = intersect(prim_list_patients, recur_list_patients)
# just 1 = "MCH3038"

```


# PUREE data

Outside of this code, I entered the data after normalization and sequencing batch correction into a tumor purity estimation tool called PUREE.  Here I am just reading those numbers back in so we can include tumor purity estimates in downstream analysis and visualizations.

PUREE's website is https://puree.genome.sg/  

```{r ReadPUREEpurity}

# got purity estimates by entering transposed lcpm_norm_seqbatchcorrect 
#   to https://puree.genome.sg/

puree_estimates = read.csv(paste0(input_directory,"puree_tumor_purity.txt"), sep = "\t")
puree_estimates$sample_name = colnames(lcpm_norm_seqbatchcorrect)
puree_estimates$Sex[grepl("XY", puree_estimates$sample_name)] = "Male"
puree_estimates$Sex[grepl("XX", puree_estimates$sample_name)] = "Female"
```

# Sex Chromosome Genes

This pulls out expression data for specific sex chromosome genes that we have found to be predictive of the sex chromosome complement.  XIST is a transcript that signals X chromosome inactivation, so high expression of XIST indicates the presense of two X chromosomes.  8 genes on chromosome Y were chosen because they are expressed in many adult tissues.  High expression of any of these genes is evidence for presence of a Y chromosome, and it is often the case that many are consistantly highly expressed in samples with a chrY.  

```{r SexChrData}
sex_chr_genes = c("XIST","DDX3Y","EIF1AY","KDM5D","NLGN4Y","ZFY","RPS4Y1","TMSB4Y","USP9Y")

sex_chr_data = data.frame(t(lcpm_norm_seqbatchcorrect[rownames(lcpm_norm_seqbatchcorrect) %in% sex_chr_genes,]))

sex_chr_data$Sex[grepl("XY", rownames(sex_chr_data))] = "Male"
sex_chr_data$Sex[grepl("XX", rownames(sex_chr_data))] = "Female"

id=factor(rownames(sex_chr_data), levels=rownames(sex_chr_data))

sex_chr_data$puree_estimate = puree_estimates$purity
sex_chr_data$PV.ID = pheno$PV.ID

sex_chr_data$X_location = pheno$X_Final
sex_chr_data$Y_location = pheno$Y_Final
sex_chr_data$Z_location = pheno$Z_Final

sex_chr_data$imaging = pheno$Annotation

sex_chr_data$age = pheno$Age.at.U01.Diagnosis

```

# Tumor Purity Plots

This creates histograms to show how many samples have a specific level of tumor purity. These might be helpful if we want to use a specific tumor purity as a threshold.

We also make scatter plots to show how well the sex chromosome genes are correlated to purity across all the samples. 

```{r TumorPurityPlots}

ggplot(data= puree_estimates, aes(x = Sex, y=purity, fill = Sex)) + geom_violin() + geom_jitter(size = 0.75)+ ggtitle("PUREE tumor purity estimate") + theme_minimal() + ylim(0,1) 

female_puree = puree_estimates$purity[puree_estimates$Sex == "Female"]
male_puree = puree_estimates$purity[puree_estimates$Sex == "Male"]

hist(female_puree, col = "salmon", main = "PUREE tumor purity in female samples", panel.first=grid(), xlim = c(0.2,1), ylim = c(0,20))
hist(male_puree, col = "cyan3", main = "PUREE tumor purity in male samples", panel.first=grid(), xlim = c(0.2,1), ylim = c(0,28))

write.csv(puree_estimates, file = "puree_tumor_purity_annotated.csv", row.names = FALSE)

female_sex_chr_data = sex_chr_data[sex_chr_data$Sex == "Female",]
male_sex_chr_data = sex_chr_data[sex_chr_data$Sex == "Male",]

plot(female_sex_chr_data$XIST, female_sex_chr_data$puree_estimate, xlab = "XIST expression", ylab = "PUREE tumor purity (females)", pch = 16, col = "salmon")
cor.test(female_sex_chr_data$XIST, female_sex_chr_data$puree_estimate)

ggplot(female_sex_chr_data, aes(x=XIST, y=puree_estimate, color = age)) + geom_point(size=5) + scale_color_gradient(low="yellow", high = "darkgreen") + theme_minimal() + theme(axis.title = element_text(size = 14)) + xlab("XIST expression") + ylab("PUREE tumor purity (females)")

plot(male_sex_chr_data$XIST, male_sex_chr_data$puree_estimate, xlab = "XIST expression", ylab = "PUREE tumor purity (males)", pch = 16, col = "cyan3")
cor.test(male_sex_chr_data$XIST, male_sex_chr_data$puree_estimate)

ggplot(male_sex_chr_data, aes(x=XIST, y=puree_estimate, color = age)) + geom_point(size=5) + scale_color_gradient(low="yellow", high = "darkgreen") + theme_minimal() + theme(axis.title = element_text(size = 14)) + xlab("XIST expression") + ylab("PUREE tumor purity (males)")

plot(male_sex_chr_data$DDX3Y, male_sex_chr_data$puree_estimate, xlab = "DDX3Y expression", ylab = "PUREE tumor purity", pch = 16, col = "cyan3")
cor.test(male_sex_chr_data$DDX3Y, male_sex_chr_data$puree_estimate)

ggplot(male_sex_chr_data, aes(x=DDX3Y, y=puree_estimate, color = age)) + geom_point(size=5) + scale_color_gradient(low="yellow", high = "darkgreen") + theme_minimal() + theme(axis.title = element_text(size = 18)) + xlab("DDX3Y expression") + ylab("PUREE tumor purity (males)")

plot(male_sex_chr_data$RPS4Y1, male_sex_chr_data$puree_estimate, xlab = "RPS4Y1 expression", ylab = "PUREE tumor purity", pch = 16, col = "cyan3")
cor.test(male_sex_chr_data$RPS4Y1, male_sex_chr_data$puree_estimate)

ggplot(male_sex_chr_data, aes(x=RPS4Y1, y=puree_estimate, color = age)) + geom_point(size=5) + scale_color_gradient(low="yellow", high = "darkgreen") + theme_minimal() + theme(axis.title = element_text(size = 18)) + xlab("RPS4Y1 expression") + ylab("PUREE tumor purity (males)")

plot(male_sex_chr_data$ZFY, male_sex_chr_data$puree_estimate, xlab = "ZFY expression", ylab = "PUREE tumor purity", pch = 16, col = "cyan3")
cor.test(male_sex_chr_data$ZFY, male_sex_chr_data$puree_estimate)

ggplot(male_sex_chr_data, aes(x=ZFY, y=puree_estimate, color = age)) + geom_point(size=5) + scale_color_gradient(low="yellow", high = "darkgreen") + theme_minimal() + theme(axis.title = element_text(size = 18)) + xlab("ZFY expression") + ylab("PUREE tumor purity (males)")

plot(male_sex_chr_data$USP9Y, male_sex_chr_data$puree_estimate, xlab = "USP9Y expression", ylab = "PUREE tumor purity", pch = 16, col = "cyan3")
cor.test(male_sex_chr_data$USP9Y, male_sex_chr_data$puree_estimate)

ggplot(male_sex_chr_data, aes(x=USP9Y, y=puree_estimate, color = age)) + geom_point(size=5) + scale_color_gradient(low="yellow", high = "darkgreen") + theme_minimal() + theme(axis.title = element_text(size = 18)) + xlab("USP9Y expression") + ylab("PUREE tumor purity (males)")

# split by patient

# XIST
for (patient_id in (levels(as.factor(sex_chr_data$PV.ID)))) {
  patient_sex_chr_data = sex_chr_data[sex_chr_data$PV.ID == patient_id,]
  if (nrow(patient_sex_chr_data) >= 3) {
    
    # get correlation and plot of purity by XIST
    cortest = cor.test(patient_sex_chr_data$XIST, patient_sex_chr_data$puree_estimate)
    coef = round(as.numeric(cortest$estimate), digits = 3)
    pv = round(as.numeric(cortest$p.value), digits = 3)
    sex_color = ifelse(patient_sex_chr_data$Sex[1] == "Male", "cyan3","salmon")
    #plot(patient_sex_chr_data$XIST, patient_sex_chr_data$puree_estimate, xlab = "XIST expression", ylab = "PUREE tumor purity", pch = 16, col = sex_color, main = paste0(patient_id," (sex =",patient_sex_chr_data$Sex[1],", R =",coef,", p = ",pv, ")"))
    
    p = ggplot(patient_sex_chr_data, aes(x=XIST, y=puree_estimate, color = age)) + geom_point(size=5) + scale_color_gradient(low="yellow", high = "darkgreen") + theme_minimal() + theme(axis.title = element_text(size = 14)) + xlab("XIST expression") + ylab("PUREE tumor purity (males)") + ggtitle(paste0(patient_id," (sex =",patient_sex_chr_data$Sex[1],", R =",coef,", p = ",pv, ")"))
    print(p)
  }
  
  # plot in 3D by location
  #scatterplot3d::scatterplot3d(x=patient_sex_chr_data$X_location,y=patient_sex_chr_data$Y_location, z=patient_sex_chr_data$Z_location, pch = 16)
  
}

# DDX3Y
for (patient_id in (levels(as.factor(sex_chr_data$PV.ID)))) {
  patient_sex_chr_data = sex_chr_data[sex_chr_data$PV.ID == patient_id,]
  if (nrow(patient_sex_chr_data) >= 3) {
    cortest = cor.test(patient_sex_chr_data$DDX3Y, patient_sex_chr_data$puree_estimate)
    coef = round(as.numeric(cortest$estimate), digits = 3)
    pv = round(as.numeric(cortest$p.value), digits = 3)
    sex_color = ifelse(patient_sex_chr_data$Sex[1] == "Male", "cyan3","salmon")
    #plot(patient_sex_chr_data$DDX3Y, patient_sex_chr_data$puree_estimate, xlab = "DDX3Y expression", ylab = "PUREE tumor purity", pch = 16, col = sex_color, main = paste0(patient_id," (sex =",patient_sex_chr_data$Sex[1],", R =",coef,", p = ",pv, ")"))
    
    p = ggplot(patient_sex_chr_data, aes(x=DDX3Y, y=puree_estimate, color = age)) + geom_point(size=5) + scale_color_gradient(low="yellow", high = "darkgreen") + theme_minimal() + theme(axis.title = element_text(size = 14)) + xlab("DDX3Y expression") + ylab("PUREE tumor purity (males)") + ggtitle(paste0(patient_id," (sex =",patient_sex_chr_data$Sex[1],", R =",coef,", p = ",pv, ")"))
    print(p)
  }
}

# 3D plots males

genes_for_3D = c("MCH3344", "MCH2868","MCH3697", "MCH3032", "MCH3692")
library(plotly)

#----------------------
patient_id = "MCH3344"
patient_sex_chr_data = sex_chr_data[sex_chr_data$PV.ID == patient_id,]

plot_ly(x=patient_sex_chr_data$X_location,y=patient_sex_chr_data$Y_location, z=patient_sex_chr_data$Z_location, type = "scatter3d", mode = "markers", marker=list(color = patient_sex_chr_data$DDX3Y, size = patient_sex_chr_data$puree_estimate * 40, colorscale="Blues", colorbar = list(colorscale = "Blues"))) %>% layout(title = paste0(patient_id, " DDX3Y expression"))

plot_ly(x=patient_sex_chr_data$X_location,y=patient_sex_chr_data$Y_location, z=patient_sex_chr_data$Z_location, type = "scatter3d", mode = "markers", marker=list(color = patient_sex_chr_data$puree_estimate, colorscale="Blues", colorbar = list(colorscale = "Blues"))) %>% layout(title = paste0(patient_id, " purity"))

col.set <- as.factor(patient_sex_chr_data$imaging)
levels(col.set) # ENH
plot_ly(patient_sex_chr_data, x=patient_sex_chr_data$X_location,y=patient_sex_chr_data$Y_location, z=patient_sex_chr_data$Z_location, type = "scatter3d", mode = "markers", color = patient_sex_chr_data$imaging, colors = c("darkred")) %>% layout(title = paste0(patient_id, " imaging annotation"))

#----------------------

# BEST EXAMPLE, included in report
patient_id = "MCH2868"
patient_sex_chr_data = sex_chr_data[sex_chr_data$PV.ID == patient_id,]

scene = list(camera = list(eye = list(x = 0, y = 0, z = 0)))

plot_ly(x=patient_sex_chr_data$X_location,y=patient_sex_chr_data$Y_location, z=patient_sex_chr_data$Z_location, type = "scatter3d", mode = "markers", marker=list(color = patient_sex_chr_data$DDX3Y, colorscale="PuRd", colorbar = list(colorscale = "PuRd"))) %>% layout(title = paste0(patient_id, " DDX3Y expression"), scene = scene)

plot_ly(x=patient_sex_chr_data$X_location,y=patient_sex_chr_data$Y_location, z=patient_sex_chr_data$Z_location, type = "scatter3d", mode = "markers", marker=list(color = patient_sex_chr_data$puree_estimate, colorscale="PuRd", colorbar = list(colorscale = "PuRd"))) %>% layout(title = paste0(patient_id, " purity"), scene = scene)

col.set <- as.factor(patient_sex_chr_data$imaging)
levels(col.set) # BAT, ENH
plot_ly(patient_sex_chr_data, x=patient_sex_chr_data$X_location,y=patient_sex_chr_data$Y_location, z=patient_sex_chr_data$Z_location, type = "scatter3d", mode = "markers", color = patient_sex_chr_data$imaging, colors = c("lightblue","blue")) %>% layout(title = paste0(patient_id, " imaging annotation"), scene = scene)


#----------------------

# do not have locations for this patient
#patient_id = "MCH3697"
#patient_sex_chr_data = sex_chr_data[sex_chr_data$PV.ID == patient_id,]
#plot_ly(x=patient_sex_chr_data$X_location,y=patient_sex_chr_data$Y_location, z=patient_sex_chr_data$Z_location, type = "scatter3d", mode = "markers", marker=list(color = patient_sex_chr_data$DDX3Y, size = patient_sex_chr_data$puree_estimate * 40, colorscale="Blues", colorbar = list(colorscale = "Blues"))) %>% layout(title = paste0(patient_id, " DDX3Y expression"))
#----------------------

patient_id =  "MCH3032"
patient_sex_chr_data = sex_chr_data[sex_chr_data$PV.ID == patient_id,]
plot_ly(x=patient_sex_chr_data$X_location,y=patient_sex_chr_data$Y_location, z=patient_sex_chr_data$Z_location, type = "scatter3d", mode = "markers", marker=list(color = patient_sex_chr_data$DDX3Y, size = patient_sex_chr_data$puree_estimate * 40, colorscale="Blues", colorbar = list(colorscale = "Blues"))) %>% layout(title = paste0(patient_id, " DDX3Y expression"))

plot_ly(x=patient_sex_chr_data$X_location,y=patient_sex_chr_data$Y_location, z=patient_sex_chr_data$Z_location, type = "scatter3d", mode = "markers", marker=list(color = patient_sex_chr_data$puree_estimate, colorscale="Blues", colorbar = list(colorscale = "Blues"))) %>% layout(title = paste0(patient_id, " purity"))

col.set <- as.factor(patient_sex_chr_data$imaging)
levels(col.set) # ENH
plot_ly(patient_sex_chr_data, x=patient_sex_chr_data$X_location,y=patient_sex_chr_data$Y_location, z=patient_sex_chr_data$Z_location, type = "scatter3d", mode = "markers", color = patient_sex_chr_data$imaging, colors = c("grey","darkred")) %>% layout(title = paste0(patient_id, " imaging annotation"))


# no locations
#patient_id = "MCH3692"
#patient_sex_chr_data = sex_chr_data[sex_chr_data$PV.ID == patient_id,]
#plot_ly(x=patient_sex_chr_data$X_location,y=patient_sex_chr_data$Y_location, #z=patient_sex_chr_data$Z_location, type = "scatter3d", mode = "markers", marker=list(color = patient_sex_chr_data$DDX3Y, size = patient_sex_chr_data$puree_estimate * 40, colorscale="Blues", colorbar = list(colorscale = "Blues"))) %>% layout(title = paste0(patient_id, " DDX3Y expression"))

# 3D plots females

genes_for_3D = c("MCH3253", "BNI129", "BNI190")

#----------------------

patient_id = "MCH3253"
patient_sex_chr_data = sex_chr_data[sex_chr_data$PV.ID == patient_id,]

plot_ly(x=patient_sex_chr_data$X_location,y=patient_sex_chr_data$Y_location, z=patient_sex_chr_data$Z_location, type = "scatter3d", mode = "markers", marker=list(color = patient_sex_chr_data$XIST, size = patient_sex_chr_data$puree_estimate * 40, colorscale="Oranges", colorbar = list(colorscale = "Oranges"))) %>% layout(title = paste0(patient_id, " XIST expression"))

plot_ly(x=patient_sex_chr_data$X_location,y=patient_sex_chr_data$Y_location, z=patient_sex_chr_data$Z_location, type = "scatter3d", mode = "markers", marker=list(color = patient_sex_chr_data$puree_estimate, colorscale="Oranges", colorbar = list(colorscale = "Oranges"))) %>% layout(title = paste0(patient_id, " purity"))

col.set <- as.factor(patient_sex_chr_data$imaging)
levels(col.set) # BAT, ENH
plot_ly(patient_sex_chr_data, x=patient_sex_chr_data$X_location,y=patient_sex_chr_data$Y_location, z=patient_sex_chr_data$Z_location, type = "scatter3d", mode = "markers", color = patient_sex_chr_data$imaging, colors = c("grey","darkred")) %>% layout(title = paste0(patient_id, " imaging annotation"))


#----------------------

patient_id = "BNI129"
patient_sex_chr_data = sex_chr_data[sex_chr_data$PV.ID == patient_id,]

plot_ly(x=patient_sex_chr_data$X_location,y=patient_sex_chr_data$Y_location, z=patient_sex_chr_data$Z_location, type = "scatter3d", mode = "markers", marker=list(color = patient_sex_chr_data$XIST, size = patient_sex_chr_data$puree_estimate * 40, colorscale="Oranges", colorbar = list(colorscale = "Oranges"))) %>% layout(title = paste0(patient_id, " XIST expression"))

plot_ly(x=patient_sex_chr_data$X_location,y=patient_sex_chr_data$Y_location, z=patient_sex_chr_data$Z_location, type = "scatter3d", mode = "markers", marker=list(color = patient_sex_chr_data$puree_estimate, colorscale="Oranges", colorbar = list(colorscale = "Oranges"))) %>% layout(title = paste0(patient_id, " purity"))

col.set <- as.factor(patient_sex_chr_data$imaging)
levels(col.set) # BAT, ENH
plot_ly(patient_sex_chr_data, x=patient_sex_chr_data$X_location,y=patient_sex_chr_data$Y_location, z=patient_sex_chr_data$Z_location, type = "scatter3d", mode = "markers", color = patient_sex_chr_data$imaging, colors = c("grey","darkred")) %>% layout(title = paste0(patient_id, " imaging annotation"))


#----------------------

patient_id = "BNI190"
patient_sex_chr_data = sex_chr_data[sex_chr_data$PV.ID == patient_id,]

plot_ly(x=patient_sex_chr_data$X_location,y=patient_sex_chr_data$Y_location, z=patient_sex_chr_data$Z_location, type = "scatter3d", mode = "markers", marker=list(color = patient_sex_chr_data$XIST, size = patient_sex_chr_data$puree_estimate * 40, colorscale="Oranges", colorbar = list(colorscale = "Oranges"))) %>% layout(title = paste0(patient_id, " XIST expression"))

plot_ly(x=patient_sex_chr_data$X_location,y=patient_sex_chr_data$Y_location, z=patient_sex_chr_data$Z_location, type = "scatter3d", mode = "markers", marker=list(color = patient_sex_chr_data$puree_estimate, colorscale="Oranges", colorbar = list(colorscale = "Oranges"))) %>% layout(title = paste0(patient_id, " purity"))

col.set <- as.factor(patient_sex_chr_data$imaging)
levels(col.set) # BAT, ENH
plot_ly(patient_sex_chr_data, x=patient_sex_chr_data$X_location,y=patient_sex_chr_data$Y_location, z=patient_sex_chr_data$Z_location, type = "scatter3d", mode = "markers", color = patient_sex_chr_data$imaging, colors = c("grey","darkred")) %>% layout(title = paste0(patient_id, " imaging annotation"))


```

# Sex Chromosome Gene Expression by Sex

This shows the distribution of expression of sex chromosome genes in female vs male patients.

```{r SexChromosomeGenes}

for (i in 1:length(sex_chr_data)) {
  gene = colnames(sex_chr_data) [i]
  gene_bar = ggplot(data= sex_chr_data, aes(x = id, y= sex_chr_data[[i]], fill = Sex)) + geom_bar(stat = "identity") + ggtitle(paste0(gene, " expression (seqbatch normalized)")) + theme_minimal() + theme(axis.title.x = element_blank(), axis.text.x = element_blank()) + ylab(paste0(gene, " norm expression"))
  print(gene_bar)
  
  gene_box = ggplot(data= sex_chr_data, aes(x = Sex, y= sex_chr_data[[i]], fill = Sex)) + geom_boxplot() + geom_jitter(size = 0.75)+ ggtitle(paste0(gene, " expression (seqbatch normalized)")) + theme_minimal() + ylab(paste0(gene, " norm expression"))
  print(gene_box)
  
  gene_box = ggplot(data= sex_chr_data, aes(x = Sex, y= sex_chr_data[[i]], fill = PV.ID)) + geom_boxplot(show.legend = FALSE) + geom_jitter(size = 0.5)+ ggtitle(paste0(gene, " expression (seqbatch normalized)")) + scale_size("PV.ID") + theme_minimal() + ylab(paste0(gene, " norm expression")) + theme(legend.position = "none")
  print(gene_box)
  
  gene_violin = ggplot(data= sex_chr_data, aes(x = Sex, y= sex_chr_data[[i]], fill = Sex)) + geom_violin() + geom_jitter() + ggtitle(paste0(gene, " expression (seqbatch normalized)")) + theme_minimal() + ylab(paste0(gene, " norm expression"))
  print(gene_violin)
  
  gene_violin = ggplot(data= sex_chr_data, aes(x = Sex, y= sex_chr_data[[i]], fill = Sex, size = puree_estimate)) + geom_violin() + geom_jitter() + scale_size("puree_estimate") + ggtitle(paste0(gene, " expression (seqbatch normalized)")) + theme_minimal() + ylab(paste0(gene, " norm expression"))
  print(gene_violin)
  
}

# heatmap

sex_chr_data_v = t(sex_chr_data[1:9])

annotDF = data.frame(sex_chr_data$Sex)
colnames(annotDF) = c("Sex")
rownames(annotDF) = rownames(sex_chr_data)
annotColors = list(Sex = c(Female = "orange", Male = "blue"))

pheatmap(as.matrix(sex_chr_data_v), show_colnames = FALSE, annotation_col = annotDF, annotation_colors = annotColors)

pheatmap(as.matrix(sex_chr_data_v), show_colnames = FALSE, annotation_col = annotDF, annotation_colors = annotColors, scale = "row")

for (patient_id in (levels(as.factor(sex_chr_data$PV.ID)))) {
  # filter samples within the patient
  # if there are more than 3 samples, make heatmap
  
  sex_chr_data_filt = data.frame(sex_chr_data[sex_chr_data$PV.ID == patient_id,])
  sex_chr_data_filt = sex_chr_data_filt[order(sex_chr_data_filt$puree_estimate, decreasing = TRUE),]
  
  if(nrow(sex_chr_data_filt) >= 3) {

    corr_purity = rep(0,length(sex_chr_genes))
    for (i in 1:9) {
      corrtest = cor.test(sex_chr_data_filt[[i]],sex_chr_data_filt$puree_estimate)
      corr_purity[i] = corrtest$estimate
    }
    corr_purity = unlist(corr_purity)
    names(corr_purity) = colnames(sex_chr_data_filt[1:9])

    target = names(corr_purity[order(corr_purity,decreasing=TRUE)])

    sex_chr_data_v_filt = t(sex_chr_data_filt[1:9])

    sex_chr_data_v_filt = sex_chr_data_v_filt[match(target,rownames(sex_chr_data_v_filt)),]

    annotDF_filt = data.frame(floor(sex_chr_data_filt$puree_estimate * 100))
    colnames(annotDF_filt) = c("Purity")
    rownames(annotDF_filt) = rownames(sex_chr_data_filt)
    
    annotDF_row_filt = data.frame(corr_purity[order(corr_purity,decreasing=TRUE)])
    rownames(annotDF_row_filt) = rownames(sex_chr_data_v_filt)
    colnames(annotDF_row_filt) = c("CorrPurity")
    
    annotColors_filt = list(Purity = c("white", "firebrick"), CorrPurity = c("white", "firebrick"))
        
    sex_of_patient = levels(as.factor(sex_chr_data_filt$Sex))
    
    pheatmap(as.matrix(sex_chr_data_v_filt), cluster_rows = FALSE, cluster_cols = FALSE, annotation_col = annotDF_filt, annotation_row = annotDF_row_filt, annotation_colors = annotColors_filt, main = paste0(patient_id,",",sex_of_patient[1]))
    pheatmap(as.matrix(sex_chr_data_v_filt), clustering_distance_rows = "correlation", cluster_rows = TRUE, cluster_cols = FALSE, annotation_col = annotDF_filt, annotation_colors = annotColors_filt, main = paste0(patient_id,",",sex_of_patient[1]))
    
  }
}

```

# EPIC to compare deconvolution
```{r EPIC}

#devtools::install_github("GfellerLab/EPIC", build_vignettes=TRUE)
library(EPIC)
EPIC_default <- EPIC(bulk = lcpm_norm_seqbatchcorrect)
write.csv(EPIC_default$cellFractions, file = "EPIC_default_cellproportions.csv")

epic_fractions = data.frame(EPIC_default$cellFractions)
rownames(epic_fractions) == puree_estimates$sample_name

plot(epic_fractions$otherCells, puree_estimates$purity)

cor.test(epic_fractions$otherCells, puree_estimates$purity)

```


# Quantiseq to compare immune deconvolution

```{r Quantiseq, eval=FALSE, include=FALSE}

library(immunedeconv)
library(DGEobj.utils)

# TO FIX: data has to be TPM and not log according to the vignette

# Notes on how to get gene length from gene names (IDs... might have to do something different for gene name)
# https://bioinformatics.stackexchange.com/questions/4942/finding-gene-length-using-ensembl-id

x_norm_seqbatchcorrect = removeBatchEffect(x_norm$counts, batch=pheno$Sequencing_Batch)

res_quantiseq <- deconvolute(as.matrix(x_norm_seqbatchcorrect), "quantiseq", tumor=TRUE)
# get error: 
#  >>> Running quantiseq

# Running quanTIseq deconvolution module

# Gene expression normalization and re-annotation (arrays: FALSE)

#Error in `.rowNamesDF<-`(x, value = value) : 
#  duplicate 'row.names' are not allowed
#In addition: Warning message:
#non-unique value when setting 'row.names': ‘entry withdrawn’

res_xcell <- deconvolute(x_norm_seqbatchcorrect, "xcell", tumor=TRUE)
res_mcp_counter <- deconvolute(x_norm_seqbatchcorrect, "mcp_counter", tumor=TRUE)


```


# Tumor Purity with tidyestimate

```{r TumorPurityTIDYESTIMATE, eval=FALSE, include=FALSE}

# According to vignette, should not be used for non-Affymetrix data

BiocManager::install("tidyestimate")
library(tidyestimate)

filtered = filter_common_genes(lcpm_norm_seqbatchcorrect, id = "hgnc_symbol", tidy = FALSE, tell_missing = TRUE, find_alias = TRUE)

scored = estimate_score(filtered, is_affymetrix = FALSE)
```


# Differential expression with DREAM

```{r DesignMatrixContrasts, eval=TRUE, tidy=TRUE, tidy.opts=list(width.cutoff=60)}

# put normalized batch corrected data on positive range so we can use the DGEList functions
lcpm_norm_seqbatchcorrect_posrange = lcpm_norm_seqbatchcorrect + (-1 * min(lcpm_norm_seqbatchcorrect)) + 1

# load data into a DGEList object
x_seqbatchcorrect <- DGEList(counts = lcpm_norm_seqbatchcorrect_posrange, lib.size = colSums(lcpm_norm_seqbatchcorrect_posrange), norm.factors = rep(1,ncol(lcpm_norm_seqbatchcorrect_posrange)), samples = colnames(lcpm_norm_seqbatchcorrect_posrange), group = pheno$Sex, genes = row.names(lcpm_norm_seqbatchcorrect_posrange), remove.zeros = TRUE)

form = ~ Sex + (1 | Subject.ID) + Age.at.U01.Diagnosis

# estimate weights using linear mixed model of dream
v = voomWithDreamWeights(x_seqbatchcorrect, form, pheno)

# Fit the dream model on each gene
# For the hypothesis testing, by default,
# dream() uses the KR method for <= 20 samples,
# otherwise it uses the Satterthwaite approximation
fitmm = dream(v, form, pheno)
fitmm <- eBayes(fitmm)

# take a look at the top results
head(fitmm$design, 3)

# print out the full results table for further analysis
results = topTable(fitmm, coef = "SexM", n=Inf)

write.csv(results, file = "dream_diffexpr_sex_PlusAge.csv")


```

# Volcano plot

A volcano plot shows log fold change on the x-axis and log p-value on the y axis. Log fold change is given a positive sign if average expression in females is higher or negative if average expression in males is higher. This brings genes that are significantly differentially expressed away from both axes.  The EnhancedVolcano function shown here does a lot of labeling and coloring automatically, which is pleasing to the eye and very convenient for making figures for papers and presentations.

``` {r VolcanoPlot, eval=TRUE, tidy=TRUE, tidy.opts=list(width.cutoff=60), fig.height=8}

# volcano plot

pdf(paste0(input_directory, "EnhancedVolcano_adjpv_sexDEG_dream_PlusAge.pdf"))
EnhancedVolcano(results, lab = results$genes, x = 'logFC', y = 'adj.P.Val',labSize=3, FCcutoff = 0.66, pCutoff = 0.05, drawConnectors = TRUE)
dev.off()

EnhancedVolcano(results, lab = results$genes, x = 'logFC', y = 'P.Value',labSize=3, FCcutoff = 1, pCutoff = 0.05, drawConnectors = TRUE)

length(results$genes[results$adj.P.Val < 0.05])
length(results$genes[results$P.Value < 0.01])

```

# Get table of differentially expressed genes

```{r DEGtable}

library(gridExtra)
library(ggplot2)
sig_results = results[results$adj.P.Val<0.05,]
sig_results2 = sig_results[c(2,5,6)]
sig_results2$P.Value = signif(sig_results2$P.Value, digits = 3)
sig_results2$adj.P.Val = signif(sig_results2$adj.P.Val, digits = 3)
sig_results2$logFC = round(sig_results2$logFC,3)

male_sig_results = sig_results2[sig_results2$logFC>0 & sig_results2$logFC > 0.3,]
female_sig_results = sig_results2[sig_results2$logFC<0  & sig_results2$logFC < -0.3,]

png(paste0(input_directory,"table_male_sig_adjp_sexDEG_dream.png"), height = 600, width = 300)
p_m = tableGrob(male_sig_results)
grid.arrange(p_m)
dev.off()

png(paste0(input_directory,"table_female_sig_adjp_sexDEG_dream.png"), height = 200, width = 300)
p_f = tableGrob(female_sig_results)
grid.arrange(p_f)
dev.off()


```
# VariancePartition

This is a tool we can use to see which values to include as covariates when doing differential expression analysis and other modelling.  It takes a lot of time to run, so it will often be turned off, but there the output is included in a PDF in the data directory from a previous report print.  

```{r VariancePartition, eval=FALSE}
# create groups for the phenotypes that are different between the samples 
pheno$purity = puree_estimates$purity

# continuous variables
survival_time <- factor(as.numeric(pheno$Survival_Time))
age_diagnosis <- factor(as.numeric(pheno$Age.at.U01.Diagnosis))
purity = factor(puree_estimates$purity)

# discrete variables
sex <- factor(pheno$Sex, levels=c("F", "M"))
grade <- factor(pheno$Grade, levels=c("2", "3", "4", "Unk"))
recurrance <- factor(pheno$Primary.Recurrent, levels=c("Primary", "Recurrent"))

   # imaging phenotypes non-redundant
imaging_phenotypes = pheno$Annotation
imaging_phenotypes[grep("BAT",imaging_phenotypes)] = "NonENH"
imaging_phenotypes[grep("NE",imaging_phenotypes)] = "NonENH"
imaging_phenotypes[grep("CE",imaging_phenotypes)] = "ENH"
imaging_phenotypes[grep("Central Cyst/Cavity",imaging_phenotypes)] = "Cyst_Cavity"
imaging_phenotypes[grep("Necrosis",imaging_phenotypes)] = "NEC"
imaging <- factor(imaging_phenotypes) # set to imaging


# add groups to samples in dge list 

x_seqbatchcorrect$survival_time = survival_time
x_seqbatchcorrect$age_diagnosis = age_diagnosis
x_seqbatchcorrect$sex = sex
x_seqbatchcorrect$grade = grade
x_seqbatchcorrect$recurrance = recurrance
x_seqbatchcorrect$imaging = imaging
x_seqbatchcorrect$purity = purity

# Add covariates to test
#covariates = ~ survival_time + age_diagnosis + (1|sex) + (1|seqbatch) + (1|grade) + (1|recurrance) 
#covariates = ~ (1|sex) + (1|seqbatch) + (1|grade) + (1|recurrance) + (1|imaging)
#covariates = ~ survival_time + age_diagnosis 

covariates = ~ (1|sex) + (1|grade) + (1|recurrance) + (1|imaging)
#covariates = ~ purity + age_diagnosis

varPart = fitExtractVarPartModel(x_seqbatchcorrect$counts, covariates, pheno)
varPart_sorted = sortCols(varPart)

plotVarPart(varPart_sorted)
#write.csv(varPart_sorted, paste0(input_directory,"varPart_sorted_seqbatchcorrected.csv"))
write.csv(varPart_sorted, paste0(input_directory,"varPart_sorted_seqbatchcorrected_purity_age.csv"))

plotPercentBars(varPart_sorted[1:10,])

# jitter plots of features
#ggplot(pheno, aes(case_control,mother_age)) + geom_boxplot() + geom_point(aes(colour = sex, shape = sex), size = 3, position=position_jitter(width = 0.2, height = 0))

```


# Compare to TCGA

```{r TCGAcompare}

# compare signlog pvalue
sexDEG_data = read.csv(paste0(input_directory,"dream_diffexpr_sex_v_TCGA.csv"))

ggplot(sexDEG_data, aes(x=signlogP.Value_Mayo,y=signlogP.Value_TCGA)) + geom_point(col = "darkblue") + theme_minimal() + xlab("Mayo GBM (signed log t-test p-value)") + ylab("TCGA GBM (signed log t-test p-value)") + ggtitle("Sex differential gene expression")

cor.test(sexDEG_data$signlogP.Value_TCGA, sexDEG_data$signlogP.Value_Mayo)

# transform TCGA gene expression data to run PUREE
TCGA_TPM = read.csv(paste0(input_directory,"TCGA_GBM_gene_expression/TCGA-GBM-TPM_shortheading_genename.txt"), sep = "\t")

TCGA_TPM <- TCGA_TPM[ rowSums(TCGA_TPM[2:ncol(TCGA_TPM)])>10, ]
TCGA_TPM_transpose = t(TCGA_TPM)
colnames(TCGA_TPM_transpose) = TCGA_TPM$gene_name
TCGA_TPM_transpose = TCGA_TPM_transpose[-1,]

write.table(t(TCGA_TPM), file =  paste0(input_directory,"TCGA_GBM_gene_expression/TCGA-GBM-TPM_shortheading_genename_filtsum10_transpose.csv"),col.names = FALSE, sep = ",")

# load PUREE results 

TCGA_purity = read.csv(paste0(input_directory,"TCGA_GBM_gene_expression/TCGA-GBM-TPM_shortheading_genename_filtsum10_transpose_puree.txt"), sep = "\t")

Mayo_purity = cbind(rep("Mayo_GBM",length(puree_estimates$purity)), puree_estimates$purity)
TCGA_purity2 = cbind(rep("TCGA_GBM",length(TCGA_purity$purity)),TCGA_purity$purity)
all_purity = rbind(Mayo_purity,TCGA_purity2)
colnames(all_purity) = c("Dataset","PurityEstimate")

ggplot(all_purity, aes(x = Dataset, y = as.numeric(PurityEstimate))) + 
  geom_boxplot() + 
  geom_jitter(shape=16, position=position_jitter(0.2)) + 
  theme_minimal() +
  ylab ("Purity Estimate(PUREE)")
```


# List all the packages used for future reference
```{r SessionInfo}
sessionInfo()
```

